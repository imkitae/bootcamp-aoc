# Day 1

## 파트 1

주어진 입력의 모든 숫자를 더하시오.

예) +10 -2 -5 +1 이 입력일 경우 4를 출력

## 파트 2

주어진 입력의 숫자를 더할 때 마다 나오는 숫자 중, 처음으로 두번 나오는 숫자를 리턴하시오.

예) +3, +3, +4, -2, -4 는 10이 처음으로 두번 나오는 숫자임.
0 -> 3 (+3) -> 6 (+3) -> 10(+4) -> 8(-2) -> 4(-4) -> 7(+3) -> 10(+3) -> ...

# Day 2

## 파트 1

주어진 각각의 문자열에서, 같은 문자가 두번 혹은 세번씩 나타난다면 각각을 한번씩 센다.
두번 나타난 문자가 있는 문자열의 수 _ 세번 나타난 문자가 있는 문자열의 수를 반환하시오.
예)
abcdef 어떤 문자도 두번 혹은 세번 나타나지 않음 -> (두번 나오는 문자열 수: 0, 세번 나오는 문자열 수: 0)
bababc 2개의 a, 3개의 b -> (두번 나오는 문자열 수: 1, 세번 나오는 문자열 수: 1)
abbcde 2개의 b -> (두번 나오는 문자열 수: 2, 세번 나오는 문자열 수: 1)
abcccd 3개의 c -> (두번 나오는 문자열 수: 2, 세번 나오는 문자열 수: 2)
aabcdd 2개의 a, 2개의 d 이지만, 한 문자열에서 같은 갯수는 한번만 카운트함 -> (두번 나오는 문자열 수: 3, 세번 나오는 문자열 수: 2)
abcdee 2개의 e -> (두번 나오는 문자열 수: 4, 세번 나오는 문자열 수: 2)
ababab 3개의 a, 3개의 b 지만 한 문자열에서 같은 갯수는 한번만 카운트함 -> (두번 나오는 문자열 수: 4, 세번 나오는 문자열 수: 3)
답 : 4 _ 3 = 12

## 파트 2

여러개의 문자열 중, 같은 위치에 정확히 하나의 문자가 다른 문자열 쌍에서 같은 부분만을 리턴하시오.

예)

```
abcde
fghij
klmno
pqrst
fguij
axcye
wvxyz
```

주어진 예시에서 fguij와 fghij는 같은 위치 (2번째 인덱스)에 정확히 한 문자 (u와 h)가 다름. 따라서 같은 부분인 fgij를 리턴하면 됨.

# Day 3

## 파트 1

다음과 같은 입력이 주어짐.

```
#1 @ 1,3: 4x4
#2 @ 3,1: 4x4
#3 @ 5,5: 2x2
```

`#` 뒤에 오는 숫자는 ID, @ 뒤에 오는 숫자 쌍 (a, b)는 시작 좌표, : 뒤에 오는 (c x d)는 격자를 나타냄.
입력의 정보대로 격자 공간을 채우면 아래와 같이 됨.

```
........
...2222.
...2222.
.11XX22.
.11XX22.
.111133.
.111133.
........
```

여기서 XX는 ID 1, 2, 3의 영역이 두번 이상 겹치는 지역.
겹치는 지역의 갯수를 출력하시오. (위의 예시에서는 4)

## 파트 2

입력대로 모든 격자를 채우고 나면, 정확히 한 ID에 해당하는 영역이 다른 어떤 영역과도 겹치지 않음
위의 예시에서는 ID 3 이 ID 1, 2와 겹치지 않음. 3을 출력.
겹치지 않는 영역을 가진 ID를 출력하시오. (문제에서 답이 하나만 나옴을 보장함)

# Day 4

## 파트 1

입력:

```
[1518-11-01 00:00] Guard #10 begins shift
[1518-11-01 00:05] falls asleep
[1518-11-01 00:25] wakes up
[1518-11-01 00:30] falls asleep
[1518-11-01 00:55] wakes up
[1518-11-01 23:58] Guard #99 begins shift
[1518-11-02 00:40] falls asleep
[1518-11-02 00:50] wakes up
[1518-11-03 00:05] Guard #10 begins shift
[1518-11-03 00:24] falls asleep
[1518-11-03 00:29] wakes up
[1518-11-04 00:02] Guard #99 begins shift
[1518-11-04 00:36] falls asleep
[1518-11-04 00:46] wakes up
[1518-11-05 00:03] Guard #99 begins shift
[1518-11-05 00:45] falls asleep
[1518-11-05 00:55] wakes up
```

키워드: 가드(Guard) 번호, 자는 시간(falls asleep), 일어나는 시간(wakes up).
각 가드들은 교대 근무를 시작하고 (begins shift) 졸았다가 일어났다를 반복함.
위의 예시에서 10번 가드는 0시 5분에 잤다가 25분에 일어나고, 또 0시 30분에 잠들었다가 0시 55분에 깨어남.
가드들에 대해서 자고 깨는 시간 정보들이 입력으로 주어짐.
파트 1은 “주어진 입력에 대해서, 가장 오랜시간 잠들어있었던 가드의 ID와, 그 가드가 가장 빈번하게 잠들어 있었던 분(minute)의 곱을 구하라”
만약 20번 가드가 0시 10분\~36분, 2시 5분\~11분, 3시 11분\~13분 이렇게 잠들어 있었다면, “11분“이 가장 빈번하게 잠들어 있던 ‘분’. 그럼 답은 20 \* 11 = 220.

## 파트 2

주어진 분(minute)에 가장 많이 잠들어 있던 가드의 ID와 그 분(minute)을 곱한 값을 구하라.  
예)  
1번 가드: 0시 10분\~12분, 1시 9분\~10분  
2번 가드: 0시 10분\~12분  
1번 가드는 9분x1, 10분x2, 11분x1, 12분x1  
2번 가드는 10분x1, 11분x1, 12분x1  
주어진 분에 가장 많이 잠들어 있던 가드는 10분에 2번 잠든 1번 가드이고,  
답은 가드ID x 그 분(minute) = 1 x 10 = 10

# Day 5

## 파트 1

입력: `dabAcCaCBAcCcaDA`
같은 종류의 소문자와 대문자는 서로 ‘반응‘하여 사라짐. aABb -> ‘’
사라진 자리는 진공이 되기 때문에 다른 문자들이 붙게 되고, 또 그 문자들끼리 반응할 수 있음. abBA-> aA -> ‘’
바로 옆에 붙어있어야만 서로 반응함. abAB -> abAB (반응 없음)
대문자-대문자, 소문자-소문자는 서로 반응하지 않음. aabAAB-> aabAAB (반응 없음)
예시 `dabAcCaCBAcCcaDA => dabCBAcaDA`
주어진 input 에서 최종으로 남는 문자열을 리턴하시오.

## 파트 2

주어진 문자열에서 한 유닛 (대문자와 소문자)을 전부 없앤 후 반응시켰을 때, 가장 짧은 문자열의 길이를 리턴하시오.
예를 들어 dabAcCaCBAcCcaDA 에서 a/A를 없애고 모두 반응시키면 dbCBcD가 되고 길이는 6인데 비해,
같은 문자열에서 c/C를 없애고 모두 반응시키면 daDA가 남고 길이가 4이므로 4가 가장 짧은 길이가 됨.

# Day 6

## 파트 1

입력 : 좌표의 쌍이 N개 주어짐
1, 1
1, 6
8, 3
3, 4
5, 5
8, 9
각 점은 1 tick이 지날때 마다 상,하,좌,우로 증식함.

```
..........
.A........
..........
........C.
...D......
.....E....
.B........
..........
..........
........F.
aaaaa.cccc
aAaaa.cccc
aaaddecccc
aadddeccCc
..dDdeeccc
bb.deEeecc
bBb.eeee..
bbb.eeefff
bbb.ffffFf
bbb.eeffff
```

여기서 . 으로 표기된 부분은 각 출발 지점으로부터 '같은 거리'에 있는 부분을 뜻함.
맵 크기에는 제한이 없어 무한으로 뻗어나간다고 할 때, 가장 큰 유한한 면적의 크기를 반환 (part-1)

## 파트 2

안전(safe) 한 지역은 근원지'들'로부터의 맨하탄거리(Manhattan distance, 격자를 상하좌우로만 움직일때의 최단 거리)의 '합'이 N 이하인 지역임.

```
..........
.A........
..........
...###..C.
..#D###...
..###E#...
.B.###....
..........
..........
........F.
```

Distance to coordinate A: abs(4-1) + abs(3-1) = 5
Distance to coordinate B: abs(4-1) + abs(3-6) = 6
Distance to coordinate C: abs(4-8) + abs(3-3) = 4
Distance to coordinate D: abs(4-3) + abs(3-4) = 2
Distance to coordinate E: abs(4-5) + abs(3-5) = 3
Distance to coordinate F: abs(4-8) + abs(3-9) = 10

Total distance: 5 + 6 + 4 + 2 + 3 + 10 = 30

N이 10000 미만인 안전한 지역의 사이즈를 구하시오.

# Day 7

## 파트 1

스케줄이 주어질 때, 일이 처리되는 순서를 반환하시오.
알파벳 캐릭터 하나로 대표되는 일(work)이 주어지고, 각 일을 처리하기 위해서 선행되어야 하는 일들이 스케줄 형식으로 주어짐.
```
Step C must be finished before step A can begin.
Step C must be finished before step F can begin.
Step A must be finished before step B can begin.
Step A must be finished before step D can begin.
Step B must be finished before step E can begin.
Step D must be finished before step E can begin.
Step F must be finished before step E can begin.
```
위와 같은 입력의 경우 아래 형태의 그래프가 만들어짐.


```clojure
  -->A--->B--
 /    \      \
C      -->D----->E
 \           /
  ---->F-----
```

순서는 아래와 같음.
- 처음엔 C만 가능함. C에서 시작. 만약 다른 시작점이 존재한다면 알파벳 순서로 진행.
- C 다음으로 A와 F가 가능한데, A가 알파벳 우선순위가 높으므로 A로 감.
- A 를 완료하면 B, D, F가 가능한데, 역시 알파벳 우선순위가 높은 B가 수행됨.
- 남은 D와 F중에서 D가 수행됨
- F가 수행됨
- E가 수행됨 (E는 B, D, F 모두가 선행되어야 수행될 수 있음)

결과: CABDFE


## 파트 2

파트 1에서는 일을 워커(worker)가 하나였지만, 파트 2는 5명. 즉, 동시에 5개의 일을 처리할 수 있게 됨.
그리고 각각의 일 (A~Z)은 처리하는데 (60+1~60+26)의 시간이 걸림. B는 62초, D는 64초, etc.

이 때, 주어진 모든 일을 처리하는데 걸리는 시간을 구하시오.


아래는 파트 1의 예시에서 워커가 2명이 된 케이스임.
```clojure
Second   Worker 1   Worker 2   Done
   0        C          .        
   1        C          .        
   2        C          .        
   3        A          F       C
   4        B          F       CA
   5        B          F       CA
   6        D          F       CAB
   7        D          F       CAB
   8        D          F       CAB
   9        D          .       CABF
  10        E          .       CABFD
  11        E          .       CABFD
  12        E          .       CABFD
  13        E          .       CABFD
  14        E          .       CABFD
  15        .          .       CABFDE
```
